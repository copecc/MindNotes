---
title: 状态压缩 DP
tags:
  - 状态压缩动态规划
  - State Compression DP
---

# 状态压缩动态规划

状态压缩动态规划（$\text{State Compression DP}$）是一种用于解决涉及多个状态组合的问题的动态规划技术。其核心思想是通过使用位掩码（$\text{bitmask}$）来表示状态，从而有效地减少状态空间的大小。

## 二元状态

在许多问题中，状态可以用二进制位来表示。例如，在一个有 $n$ 个元素的集合中，每个元素可以处于两种状态之一（选中或未选中）。可以使用一个长度为 $n$ 的二进制数来表示这些状态，其中第 $i$ 位为 $1$ 表示第 $i$ 个元素被选中，为 $0$ 表示未选中。

!!! info "常见问题类型"

    - 集合划分、子集 $\text{DP}$
    - 旅行商问题（$\text{TSP}$）
    - 排列计数 
    - $\text{Hamilton}$ 路径
    - 匹配、覆盖、分配类问题

$dp[mask][i]$ 表示当前访问的集合为 $mask$，并且最后停在节点 $i$ 的最小代价。则状态转移方程为：

$$
dp[mask \mid (1 \ll j)][j]
= \min \big( dp[mask \mid (1 \ll j)][j],\ dp[mask][i] + cost[i][j] \big)
$$

其中：

- $mask$ 表示访问过的节点集合（二进制掩码）
- $i, j$ 为节点编号，且 $j \notin mask$

时间复杂度：$O(n^2 \cdot 2^n)$，适用于 $n \leq 20$ 的情况。

???+ note "[划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/description/){target=_blank}"

    给定一个整数数组 $nums$ 和一个整数 $k$，判断是否可以将该数组分成 $k$ 个非空子集，其总和都相等。

    === "记忆化搜索"

        ```cpp
        --8<-- "code/DP/State/L698_1.cpp"
        ```

    === "递推"

        ```cpp
        --8<-- "code/DP/State/L698_2.cpp"
        ```

## 轮廓线 DP

轮廓线 $\text{DP}$（$\text{Profile DP}$）是一种用于解决二维网格问题的动态规划技术。其核心思想是逐行或逐列扫描棋盘，用轮廓线描述当前行（或列）的状态（通过使用位掩码来表示当前行的状态）。

!!! info "常见问题类型"

    - 棋盘覆盖问题（多米诺骨牌填充）
    - 障碍填充问题
    - 带限制的格点计数（如放置棋子、路径计数等）
    - 图形填充问题

$dp[i][state]$表示处理到第 $i$ 行（或列），当前轮廓线状态为 $state$ 的方案数。则状态转移方程为：

$$
dp[i+1][state'] = \sum_{\text{legal transitions}} dp[i][state]
$$

其中：

- $state$ 通常用二进制或三进制表示当前行的格子占用状态  
- 通过枚举所有合法放置方式更新下一行的 $state'$  

???+ note "[互不侵犯](https://www.luogu.com.cn/problem/P1896){target=_blank}"

    在 $N * N$ 的棋盘上放置K个国王, 使得任意两个国王不在相邻的格子上(八个方向)的方案。

    === "记忆化搜索"

        ```cpp
        --8<-- "code/DP/State/P1896_1.cpp"
        ```

    === "递推"

        ```cpp
        --8<-- "code/DP/State/P1896_2.cpp"
        ```

## 三进制状态压缩

三进制状态压缩（$\text{Ternary State Compression}$）是一种用于解决涉及三种状态组合（例如：未选、选 $A$、选 $B$）的问题的动态规划技术。其核心思想是通过使用三进制数来表示状态，从而有效地减少状态空间的大小。


状态多于二元的情况, 可以用更高进制的数表示。三进制状态表示如下：

$m$ 列的状态可用一个整数 $s$ 表示，$s$ 的三进制展开的每一位代表一列的状态（$0、1、2$）

状态 $s = s[0] * 3^0 + s[1] * 3^1 + \dots + s[m-1] * 3^{(m-1)}$

- $get(s, j)$：取 $s$ 的三进制展开的第 $j$ 位（第 $j$ 列的状态），即：$(s // 3^j) \% 3$
- $set(s, j, v)$：把 $s$ 的三进制展开的第 $j$ 位设为 $v$，返回新状态，即 $s + (v - get(s, j)) * 3^j$

!!! info "常见问题类型"

    - 轮廓线 DP 优化版（当每个格点三种状态时）
    - 涂色问题（三种颜色）
    - 匹配 / 放置带方向限制的问题


!!! tip "预处理"

    - 预处理所有可能的状态和状态转移，减少运行时计算
    - 使用位运算优化状态表示和转换

???+ note "[用三种不同颜色为网格涂色](https://leetcode.cn/problems/painting-a-grid-with-three-different-colors/description/){target=_blank}"

    给你两个整数 $m$ 和 $n$，表示一个 $m$ 行 $n$ 列的网格。请你给这个网格的每个格子涂色，且满足以下条件：

    - 每个格子只能涂成 $1$、$2$ 或 $3$ 三种颜色之一。
    - 相邻格子（上下或者左右）颜色不能相同。

    返回你给网格涂色的方案数。由于答案可能很大，请你返回方案数对 $10^9 + 7$ 取余的结果。

    ```cpp
    --8<-- "code/DP/State/L1931.cpp"
    ```