---
title: 背包 DP
tags:
  - 背包型动态规划
  - Knapsack
---

# 背包问题

背包问题（$\text{Knapsack Problem}$）是动态规划中的经典问题，通常分为两种主要类型：$\text{0-1}$ 背包问题和完全背包问题。

## 0-1 背包

在 $\text{0-1}$ 背包问题中，每个物品只能选择放入背包或不放入背包。

给定 $n$ 个物品，每个物品有一个重量 $w_i$ 和一个价值 $v_i$，以及一个最大承重 $W$ 的背包，目标是选择一些物品放入背包，使得总重量不超过 $W$，且总价值最大。

状态定义：
设 $dp[i][j]$ 表示前 $i$ 个物品中，容量不超过 $j$ 的背包所能获得的最大价值

状态转移方程：

$$
dp[i][j] =
\begin{cases}
dp[i-1][j], & \text{if } j < w_i \\
\max(dp[i-1][j], dp[i-1][j - w_i] + v_i), & \text{if } j \geq w_i
\end{cases}
$$

边界条件：

$$
\begin{aligned}
dp[0][j] &= 0 \quad (0 \leq j \leq W) \\
dp[i][0] &= 0 \quad (0 \leq i \leq n)
\end{aligned}
$$

???+ note "[采药](https://www.luogu.com.cn/problem/P1048){target=_blank}"

    有一个背包，最大承重为 $t$，有 $m$ 种物品，每种物品有一个重量 $w_i$ 和一个价值 $v_i$。现在要从中选择一些物品放入背包，每种物品最多只能选择一次。要求总重量不超过 $t$，并且总价值最大。

    === "标准DP"

        ```cpp
        --8<-- "code/DP/Knapsack/P1048_1.cpp"
        ```
    === "空间优化"

        由于 $dp[i][j]$ 只依赖于 $dp[i-1][j]$ 和 $dp[i-1][j - w_i]$，可以将二维数组优化为一维数组。

        ```cpp
        --8<-- "code/DP/Knapsack/P1048_2.cpp"
        ```

### 带依赖的 0-1 背包

在某些情况下，物品之间可能存在依赖关系，即某些物品只能在其他物品被选中时才能被选中。这种情况下的 $\text{0-1}$ 背包问题称为带依赖的 $\text{0-1}$ 背包问题。

!!! tip "树形依赖"

    如果依赖是树形结构, 可以用树形 $\text{dp}$ 解决。

??? note "[金明的预算方案](https://www.luogu.com.cn/problem/P1064){target=_blank}"

    有一个容量为 $n$ 的背包，$m$ 个可选的物品，每个物品有一个价格 $v_i$ 和一个重要度 $p_i$，物品总价值为 $v_i \times p_i$。但是有些物品是附属物品，只能在主件物品购买的情况下购买。每个主件物品可以有 $0$ 个、$1$ 个或 $2$ 个附属物品。附属物品不再有附属物品。在不超过预算的情况下, 使得购买的物品总价值最大.

    ```cpp
    --8<-- "code/DP/Knapsack/P1064.cpp"
    ```
## 分组背包

在分组背包问题中，物品被分成若干组，每组中只能选择一个物品放入背包。

给定 $n$ 个物品，这些物品被分成 $g$ 组，每个物品有一个重量 $w_i$ 和一个价值 $v_i$，以及一个最大承重 $W$ 的背包，目标是选择一些物品放入背包，使得总重量不超过 $W$，且总价值最大。

分组背包的状态定义与 $\text{0-1}$ 背包类似，设 $dp[i][j]$ 表示前 $i$ 组物品中，容量不超过 $j$ 的背包所能获得的最大价值。每组内分别选择一个物品进行状态转移。

??? note "[通天之分组背包](https://www.luogu.com.cn/problem/P1757){target=_blank}"

    有一个容量为 $m$ 的背包，$n$ 个可选的物品，每个物品有一个重量 $w_i$、一个价值 $v_i$ 和一个组别 $g_i$。现在要从中选择一些物品放入背包，要求总重量不超过 $m$，并且总价值最大。但对于每个组别，只能选择其中的一个物品放入背包。

    ```cpp
    --8<-- "code/DP/Knapsack/P1757.cpp"
    ```

## 完全背包

在完全背包问题中，每个物品可以选择放入背包多次。

给定 $n$ 个物品，每个物品有一个重量 $w_i$ 和一个价值 $v_i$，以及一个最大承重 $W$ 的背包，目标是选择一些物品放入背包，使得总重量不超过 $W$，且总价值最大。

状态定义：
设 $dp[i][j]$ 表示前 $i$ 个物品中，容量不超过 $j$ 的背包所能获得的最大价值

状态转移方程：

$$
dp[i][j] =
\begin{cases}
dp[i-1][j], & \text{if } j < w_i \\
\max(dp[i-1][j], dp[i][j - w_i] + v_i), & \text{if } j \geq w_i
\end{cases}
$$

边界条件：

$$
\begin{aligned}
dp[0][j] &= 0 \quad (0 \leq j \leq W) \\
dp[i][0] &= 0 \quad (0 \leq i \leq n)
\end{aligned}
$$

???+ note "[疯狂的采药](https://www.luogu.com.cn/problem/P1616){target=_blank}"

    有一个背包，最大承重为 $t$，有 $m$ 种物品，每种物品有一个重量 $w_i$ 和一个价值 $v_i$。现在要从中选择一些物品放入背包，每种物品可以选任意次。要求总重量不超过 $t$，并且总价值最大。

    === "标准DP"

        !!! warning "MLE"

        ```cpp
        --8<-- "code/DP/Knapsack/P1616_1.cpp"
        ```

    === "空间优化"

        由于 $dp[i][j]$ 只依赖于 $dp[i-1][j]$ 和 $dp[i][j - w_i]$，可以将二维数组优化为一维数组。
        
        注意这里需要正序遍历容量 $j$，以确保每个物品可以被多次选择。

        ```cpp
        --8<-- "code/DP/Knapsack/P1616_2.cpp"
        ```

## 多重背包

在多重背包问题中，每个物品有一个数量限制，表示每种物品最多可以选择多少次。

给定 $n$ 个物品，每个物品有一个重量 $w_i$、一个价值 $v_i$ 和一个数量限制 $c_i$，以及一个最大承重 $W$ 的背包，目标是选择一些物品放入背包，使得总重量不超过 $W$，且总价值最大。

状态定义：
设 $dp[i][j]$ 表示前 $i$ 个物品中，容量不超过 $j$ 的背包所能获得的最大价值

状态转移方程：

$$
dp[i][j] = \max_{0 \le k \le \min(c_i, \lfloor j / w_i \rfloor)} \left( dp[i-1][j - k \cdot w_i] + k \cdot v_i \right)
$$

边界条件：

$$
\begin{aligned}
dp[0][j] &= 0 \quad (0 \leq j \leq W) \\
dp[i][0] &= 0 \quad (0 \leq i \leq n)
\end{aligned}
$$

???+ note "[宝物筛选](https://www.luogu.com.cn/problem/P1776){target=_blank}"

    有一个容量为 $w$ 的背包，$n$ 个可选的物品，每个物品有一个重量 $w_i$、一个价值 $v_i$ 和一个数量限制 $c_i$。现在要从中选择一些物品放入背包，要求总重量不超过 $w$，并且总价值最大。但每种物品最多只能选择 $c_i$ 件。

    !!! warning "TLE"

        时间复杂度 $O(n \cdot w \cdot \max(c_i))$，当 $c_i$ 较大时效率较低。

    === "标准DP"

        ```cpp
        --8<-- "code/DP/Knapsack/P1776_1.cpp"
        ```

    === "空间优化"

        由于 $dp[i][j]$ 只依赖于 $dp[i-1][j]$ 和 $dp[i-1][j - k \cdot w_i]$，可以将二维数组优化为一维数组。

        ```cpp
        --8<-- "code/DP/Knapsack/P1776_2.cpp"
        ```

### 二进制优化

可以将每种物品的数量限制 $c_i$ 分解为若干个 $2^k$ 的形式，从而将多重背包问题转化为多个 $\text{0-1}$ 背包问题。

!!! example "分解方法"

    如果某种物品的数量限制为 $13$，可以将其分解为 $1 + 4 + 8$，即可以选择 $1$ 件、$4$ 件或 $8$ 件该物品。这样就将该物品转化为三种不同的物品，每种物品只能选择一次。

??? note "[宝物筛选](https://www.luogu.com.cn/problem/P1776){target=_blank}"

    ```cpp
    --8<-- "code/DP/Knapsack/P1776_3.cpp"
    ```

### 单调队列优化

对于每种物品，可以将其对容量的贡献分为若干个模 $w_i$ 的子问题，每个子问题可以使用单调队列进行优化。

对于固定物品 $i$，考虑容量 $j$ 与物品数量 $k$ 的关系：

$$
dp[i][j] = \max_{0 \le k \le c_i,\, k w_i \le j} \big( dp[i-1][j - k w_i] + k v_i \big)
$$

$j$ 只能从 $j - k w_i$ 转移而来，其他的 $j^{'}$ 不会对它的结果产生影响，因此可以对 $j$ 进行 **同余分类**：

- 对 $m = 0,1,\dots,w_i-1$，考虑所有 $j$ 满足 $j \equiv m \pmod{w_i}$  
- 设 $j = m + t \cdot w_i$，其中 $t \ge 0$，表示可以选择 $t$ 件物品 $i$  

代入公式：

$$
dp[i][m + t w_i] = \max_{0 \le k \le \min(c_i, t)} \big( dp[i-1][m + (t-k) w_i] + k v_i \big)
$$

---

注意到上式是对一个区间的最大值进行求解，考虑将其转化为滑动窗口最大值问题。

上式中的计算依赖于 $k$，而当 $t$ 变化时，$k$ 的取值范围也随之变化，导致窗口中每个候选项的贡献值都会动态改变，无法直接用滑动窗口维护。因此需要将原式转化为一个不显式依赖 $k$ 的形式。

设：

$$
g(t-k) = dp[i-1][m + (t-k) w_i] - (t-k)v_i
$$

则：

$$
dp[i][m + t w_i] = \max_{0 \le k \le \min(c_i, t)} \big( g(t-k) + t v_i \big) = \max_{0 \le k \le \min(c_i, t)} \big( g(t-k) \big) + t v_i 
$$

- 在归一化后，$k$ 只表示窗口中的相对位置，不再影响候选项的值  
- 注意到 $t v_i$ 对所有 $k$ 相同，因此只需要求 $g(t-k)$ 的滑动最大值  

于是，对于每个同余类 $m$，问题变成一个 **长度为 $c_i+1$ 的滑动窗口最大值** 问题。

---

单调队列实现

1. 遍历同余类 $m$  
2. 维护一个单调队列，存储 $(t, g(t))$，队列保证 $g(t)$ 单调递减  
3. 对每个 $t$：
      - 弹出队列中窗口左端过期的元素（保证不超过 $c_i$ 个物品）  
      - 队首 $front$ 对应的 $g(front)$ 即为最大值  
      - 更新 $dp[i][m + t w_i] = g(front) + t v_i$  



??? note "[宝物筛选](https://www.luogu.com.cn/problem/P1776){target=_blank}"

    !!! tip "单调队列优化"

        时间复杂度：$O(n W)$。

    ```cpp
    --8<-- "code/DP/Knapsack/P1776_4.cpp"
    ```
    {.annotate}

    1. 此处存储 $(t, g(t))$，方便判断队首元素是否过期，以及进行备份。因为 $dp$ 数组会被覆盖，当遍历到 $t$ 时，需要根据之前的 $dp$ 值计算 $g(t)$，但 $dp$ 数组已经被更新过了。  
    使用队列存储 $g(t)$ 相对于始终存储了 $i-1$ 行的 $dp$ 数组，可以避免这个问题。  
    另一种方法是类似 $\text{0-1}$ 背包那样，从后向前遍历 $j$。

## 背包的第 k 个解

有 $n$ 件物品和一个容量为 $W$ 的背包，每件物品有一个重量 $w_i$ 和一个价值 $v_i$。现在要从中选择一些物品放入背包，要求总重量不超过 $W$，并且总价值最大。请你计算出在所有最优方案中，第 $k$ 大的方案。

普通的 $\text{0-1}$ 背包问题，求解的是价值第 $1$ 大的解。在状态中增加一维，$dp[i][j][k]$ 表示前 $i$ 个物品，体积为 $j$ 时的价值第 $k$ 大的解。

在状态转移时，普通背包问题的 $dp(i,j)$ 由 $dp(i-1,j)$ 和 $dp(i-1,j-weight[i])$ 转移而来。因此求解第 $k$ 大的解时，需要合并 $dp(i-1,j)$ 和 $dp(i-1,j-weight[i])$ 解，保留前 $k$ 大的解。

??? note "[多人背包](https://www.luogu.com.cn/problem/P1858){target=_blank}"

    有一个容量为 $v$ 的背包，$n$ 个可选的物品，每个物品有一个重量 $w_i$ 和一个价值 $val_i$。现在要从中选择一些物品放入背包，要求总重量不超过 $v$。在所有最优方案中，计算前 $k$ 大的方案的总价值。

    === "标准DP"

        !!! warning "MLE"

        ```cpp
        --8<-- "code/DP/Knapsack/P1858_1.cpp"
        ```
    
    === "空间优化"

        考虑到解序列总是有序的，因此可以使用合并排序的方法，将两个有序的序列合并为一个有序的序列，时间复杂度为 $O(k)$。同时，类似 $\text{0-1}$ 背包问题，可以将多维数组降重。

        ```cpp
        --8<-- "code/DP/Knapsack/P1858_2.cpp"
        ```