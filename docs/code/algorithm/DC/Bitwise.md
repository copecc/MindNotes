---
title: 按位分治
tags:
  - Bitwise Divide and Conquer
  - Bitwise DC
---

# 按位分治

按位分治（$\text{Bitwise Divide and Conquer}$）是一种基于二进制表示的分治算法。它通过逐位处理整数的二进制位，从最高位到最低位，将问题划分为更小的子问题进行求解。按位分治常用于解决涉及整数集合的最大异或值、最小异或值等问题。

一般思路如下：

1. 选择位数：从最高有效位（$\text{MSB}$）开始，逐位向下处理整数的二进制表示。
2. 划分集合：根据当前处理的位，将整数集合划分为两部分：一部分是该位为 $0$ 的整数，另一部分是该位为 $1$ 的整数。
3. 递归求解：对于划分后的子集合，递归地处理下一位，直到处理完所有位或子集合为空。
4. 合并结果：根据子集合的结果，合并得到最终结果。

???+ note "[最大异或对](https://www.luogu.com.cn/problem/P10471){target=_blank}"

    给定 $n$ 个非负整数，求其中两个数的异或值的最大值。

    ```cpp
    --8<-- "code/DC/Bitwise/P10471.cpp"
    ```

???+ note "[Sum of Min of XOR](https://atcoder.jp/contests/abc425/tasks/abc425_g){target=_blank}"

    给定 $n$ 个非负整数，以及一个整数 $m$。求 $\sum_{i=0}^{m-1} \text{minXOR}(i)$，其中 $\text{minXOR}(i)$ 表示从给定整数集合中选择一个整数与 $i$ 异或得到的最小值。

    ??? hint

        当前考虑第 $k-1$ 位，将 $A$ 划分为两个子集：

        $B_0 = \{ a \in A \mid a < 2^{k-1} \}$

        $B_1 = \{ a - 2^{k-1} \mid a \in A, a \ge 2^{k-1} \}$

        ---
        
        情况 1：$M = 2^k$ （完整区间）

        1. $B_0$ 和 $B_1$ 都非空：$f(A, 2^k, k) = f(B_0, 2^{k-1}, k-1) + f(B_1, 2^{k-1}, k-1)$
        2. 只有 $B_0$ 空：$f(A, 2^k, k) = 2 \cdot f(B_1, 2^{k-1}, k-1) + 2^{2(k-1)}$

        3. 只有 $B_1$ 空：$f(A, 2^k, k) = 2 \cdot f(B_0, 2^{k-1}, k-1) + 2^{2(k-1)}$

        跨组贡献：最高位异或为 1 的情况，每对贡献 $2^{k-1}$。

        ---

        情况 2：$M \le 2^{k-1}$ （只在左半区间）

        1. 如果 $B_0$ 为空：$f(A, M, k) = f(B_1, M, k-1) + M \cdot 2^{k-1}$

        2. 如果 $B_1$ 为空：$f(A, M, k) = f(B_0, M, k-1)$

        如果某一侧为空，所有 $x$ 必然选择另一侧 $\longrightarrow$ 贡献当前位。

        ---

        情况 3：$2^{k-1} < M < 2^k$ （跨两半区间）
        
        将 $x$ 拆分为两个范围：

        1. 左半区（$0 \le x < 2^{k-1}$）：$\begin{cases}
        f(B_1, 2^{k-1}, k-1) + 2^{k-1}, & B_0 \text{ 为空} \\
        f(B_0, 2^{k-1}, k-1), & \text{否则}
        \end{cases}$

        2. 右半区（$2^{k-1} \le x < M$）：$\begin{cases}
        f(B_0, M-2^{k-1}, k-1) + 2^{k-1} \cdot (M-2^{k-1}), & B_1 \text{ 为空} \\
        f(B_1, M-2^{k-1}, k-1), & \text{否则}
        \end{cases}$

        最终答案 = 左半区贡献 + 右半区贡献。

    ```cpp
    --8<-- "code/DC/Bitwise/abc425_g.cpp"
    ```
    {.annotate}

    1. $a_0$ 和 $a_1$ 都不为空，则 $[0,m)$ 区间内的每个数都可以选择和高位相同的数进行异或，当前位贡献为 $0$
    2. 若 $a_0$ 为空，则 $[0, \text{half})$ 区间内的数都必须和 $a_1$ 中的数异或，当前位贡献为 $\text{half}$，共 $\text{half}$ 个数；$a_1$ 同理。然后分别处理左右对称两半区间（$\times 2$）
    3. $[0, \text{half})$ 区间内的数可以和当前位相同的数进行异或，当前位贡献为 $0$
    4. $[0, \text{half})$ 区间内的数只能和当前位不同的数异或，当前位贡献为 $half$，共 $\min(m, half)$ 个数
    5. $[half, m)$ 区间内的数可以和当前位相同的数进行异或，当前位贡献为 $0$
    6. $[half, m)$ 区间内的数只能和当前位不同的数异或，当前位贡献为 $half$，共 $m - half$ 个数