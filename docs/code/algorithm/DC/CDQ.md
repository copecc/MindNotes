---
title: CDQ分治
tags:
  - CDQ
  - Divide and Conquer
---

# CDQ分治

$\text{CDQ}$ 分治是通过将问题划分为更小的子问题来简化计算过程，并在合并结果时进行必要的调整。

$\text{CDQ}$ 分治通常用于解决一些需要处理大量数据的复杂问题，特别是在计算逆序对、二维平面上的点对计数等问题中。常见的应用包括：

- 点对计数问题
- 一维动态规划的优化
- 离线查询问题


## 逆序对

逆序对是指在一个数组中，前面的元素大于后面的元素的情况。计算逆序对的数量是一个经典的问题，常用的解决方法包括归并排序和树状数组。

???+ note "[逆序对](https://www.luogu.com.cn/problem/P1908){target=_blank}"

    === "分治"

        ```cpp
        --8<-- "code/DC/CDQ/P1908_1.cpp"
        ```

    === "树状数组"

        通过离散化数组元素并使用树状数组进行频率统计，可以在 $O(n \log n)$ 的时间复杂度内完成计算。

        [线段树](../DS/SegmentTree.md#权值线段树)也可以实现类似的功能，但树状数组通常更为简洁和高效。

        ```cpp
        --8<-- "code/DC/CDQ/P1908_2.cpp"
        ```

## 点对计数

类似归并排序的思路，$\text{CDQ}$ 分治将数组递归地划分为左右两部分，分别计算每部分的逆序对数量，然后在合并过程中计算跨越左右部分的逆序对数量。这样可以有效地减少计算量，提高效率。

$\text{CDQ}$ 分治解决点对计数问题的关键在于如何在合并过程中高效地计算跨越左右部分的点对数量。通常可以通过维护一个辅助数组来实现这一点。具体步骤如下：

1. 将数组递归地划分为左右两部分，直到每部分只包含一个元素
2. 点对 $(i,j)$ 可以划分为三类：
      - 完全在左半部分的点对：$i,j \in [low, mid]$
      - 完全在右半部分的点对：$i,j \in [mid+1, high]$
      - 跨越左右两部分的点对：$i \in [low, mid], j \in [mid+1, high]$
3. 递归计算左右两部分的点对数量
4. 在合并过程中，使用双指针或其他数据结构（如树状数组）来高效地计算跨越左右部分的点对数量

??? note "[【模板】三维偏序](https://www.luogu.com.cn/problem/P3810){target=_blank}"

    有 $n$ 个点 $(a_i, b_i, c_i)$，统计每个点的支配点数量。点 $p_1$ 支配点 $p_2$ 当且仅当 $a_1 \leq a_2, b_1 \leq b_2, c_1 \leq c_2$。对于每个 $k$，输出有多少点的支配点数量为 $k$。

    ```cpp
    --8<-- "code/DC/CDQ/P3810.cpp"
    ```

??? note "[Range Knapsack Query](https://atcoder.jp/contests/abc426/tasks/abc426_g){target=_blank}"

    有 $n$ 件物品和 $q$ 个查询。每件物品有一个重量 $w_i$ 和一个价值 $v_i$。每个查询给出三个整数 $(l, r, c)$，表示在区间 $[l, r]$ 内选择若干物品放入容量为 $c$ 的背包中，求能获得的最大价值。

    ```cpp
    --8<-- "code/DC/CDQ/abc426_g.cpp"
    ```

