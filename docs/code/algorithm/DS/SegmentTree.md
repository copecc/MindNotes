---
title: 线段树
tags:
  - Segment Tree
---

# 线段树

线段树（$\text{Segment Tree}$）是一种用于高效处理区间查询和区间更新的树形数据结构。它将一个数组划分为若干个区间，并在每个节点中存储这些区间的信息，从而支持快速的查询和更新操作。

## 基本操作

线段树的基本操作包括：

1. 单点修改
2. 区间加法
3. 区间赋值
4. 区间求和

其中区间操作通常使用懒标记（$\text{Lazy Propagation}$）来优化性能。

### 区间加法与区间求和

???+ note "[【模板】线段树 1](https://www.luogu.com.cn/problem/P3372){target=_blank}"

    !!! keypoints "单点修改、区间加法与区间求和"

    ```cpp
    --8<--  "code/DS/SegmentTree/P3372.cpp"
    ```
    {.annotate}

    1. 闭区间，下标从 $1$ 开始 $[1,...,n]$，根节点编号为 $1$
    2. 需要维护的一些性质：如 $sum$、$max$、$min$、$gcd$、$lcm$、均值、方差  
       $gcd$、$lcm$一般只支持单点修改、区间查询，不支持区间修改
    3. 向上更新，如果是其他性质也需要一并修改
    4. 单点修改直接到叶节点，无需懒标记  
       单点操作都可以用区间操作来代替，让区间左右端点相等即可

### 区间赋值

!!! tip "懒标记优先级"

    区间赋值 $>$ 区间乘 $>$ 区间加 $=$ 区间开方，高优先级操作应先执行


???+ note "[扶苏的问题](https://www.luogu.com.cn/problem/P1253){target=_blank}"

    !!! keypoints "区间赋值、区间加法、区间最大值、区间求和"

    ```cpp
    --8<--  "code/DS/SegmentTree/P1253.cpp"
    ```

## 更复杂的区间操作

### 乘法

!!! tip "区间乘法"

    区间乘法优先级高于区间加法，并且每次乘法操作会影响之前的加法标记，需要将加法标记也乘上相应的值

??? note "[【模板】线段树 2](https://www.luogu.com.cn/problem/P3373){target=_blank}（区间乘法）"

    给定一个长度为 $n$ 的数组，支持以下三种操作：

    1. 对区间 $[l,r]$ 乘以一个整数 $val$。
    2. 对区间 $[l,r]$ 加上一个整数 $val$。
    3. 查询区间 $[l,r]$ 的和。

    ```cpp
    --8<--  "code/DS/SegmentTree/P3373.cpp"
    ```

### 开方

!!! tip "区间开方"

    整数范围内不断开方的数列最终会收敛到 $1$，因此可以用区间最大值来判断是否需要继续递归。如果区间最大值已经是 $1$，则该区间内所有数均为 $1$，无需继续开方。否则继续递归处理子节点。

??? note "[上帝造题的七分钟 2 / 花神游历各国](https://www.luogu.com.cn/problem/P4145){target=_blank}（区间开方）"

    给定一个长度为 $n$ 的数组，支持以下两种操作：

    1. 对区间 $[l,r]$ 内的每个数开平方（向下取整）。（$op=0$）
    2. 查询区间 $[l,r]$ 的和。（$op=1$）

    ```cpp
    --8<--  "code/DS/SegmentTree/P4145.cpp"
    ```

### GCD

!!! tip "区间加法与 $\gcd$"

    $n$ 个数的 $\gcd$ 可以通过差分数组来维护。由于 $\gcd(x, y) = \gcd(x, y - x)$，因此有以下等式成立：

    $$
    \gcd(a_l, a_{l+1}, \ldots, a_r) = \gcd(a_l, a_{l+1} - a_l, a_{l+2} - a_{l+1}, \ldots, a_r - a_{r-1})
    $$

    令 $d_i = a_i - a_{i-1}$，则上式可改写为：

    $$
    \gcd(a_l, a_{l+1}, \ldots, a_r) = \gcd(a_l, d_{l+1}, d_{l+2}, \ldots, d_r)
    $$

    因此，可以使用线段树维护差分数组 $d$ 的区间 $gcd$，以及差分数组的前缀和来计算 $a_l$ 的值（$a_l = \sum_{i=1}^{l} d_i$，也可以通过树状数组维护）。

    更新时，区间加法操作会影响差分数组的两个位置：$d_l$ 增加 $val$，$d_{r+1}$ 减少 $val$（如果 $r + 1 \leq n$）。

??? note "[Interval GCD](https://www.luogu.com.cn/problem/P10463){target=_blank}（区间$\gcd$）"

    给定一个长度为 $n$ 的数组，支持以下两种操作：

    1. 对区间 $[l,r]$ 加上一个整数 $val$。（$op=C$）
    2. 查询区间 $[l,r]$ 的 $\gcd$。（$op=Q$）

    ```cpp
    --8<--  "code/DS/SegmentTree/P10463.cpp"
    ```

### 等差数列

!!! tip "区间加上等差数列"

    对于区间 $[l,r]$，将其加上等差数列 $s, s+d, s+2d, \ldots, s+(r-l)d$，可以维护一个差分数组 $D$，其中 $D_i = a_i - a_{i-1}$。则操作可以转化为：

    - $D_l = D_l + s$
    - $[D_{l+1}, D_r]$ 增加 $d$（$\text{if } l + 1 \leq r$）
    - $D_{r+1} = D_{r+1} - (s + (r - l)d) = D_{r+1} - e$（$\text{if }r + 1 \leq n$）

    也可以使用树状数组维护二阶差分数组，见[高阶差分数组](../PrefixAndDifference.md#高阶差分数组)中等差数列的性质维护。

??? note "[无聊的数列](https://www.luogu.com.cn/problem/P1438){target=_blank}"

    给定一个长度为 $n$ 的数组，支持以下两种操作：

    1. 对区间 $[l,r]$ 加上等差数列，$l$ 位置加上 $k$，之后每个位置比前一个位置多加 $d$。（$op=1$）
    2. 查询下标为 $index$ 的位置的值。（$op=2$）

    ```cpp
    --8<--  "code/DS/SegmentTree/P1438.cpp"
    ```

## 线段树二分

线段树二分（$\text{Segment Tree Binary Search}$）是一种结合线段树和二分查找的方法，用于在区间内快速定位满足某些条件的元素位置。其基本思路是利用线段树的区间信息，在查询时通过二分查找来缩小搜索范围，从而提高查询效率。

???+ note "[线段树上二分模版](https://www.luogu.com.cn/problem/U502676){target=_blank}"

    给定一个长度为 $n$ 的数组，每组询问给出 $l,r,k$，询问在 $[l,r]$ 中从左往右数第一个大于 $k$ 的数的位置（下标）。如果不存在这样的数，输出 $−1$。

    ```cpp
    --8<--  "code/DS/SegmentTree/U502676.cpp"
    ```

## 权值线段树

权值线段树（$\text{Weight Segment Tree}$）对权值（值域）进行维护，其基本思路是将每个节点的值视为一个权值，维护一个线段树来表示这些权值的分布情况，常常需要对值域进行离散化操作。

??? note "[逆序对](https://www.luogu.com.cn/problem/P1908){target=_blank}"

    求数组中的逆序对数。

    ```cpp
    --8<--  "code/DS/SegmentTree/P1908.cpp"
    ```


## 非对称信息维护

在区间查询时，有时需要维护一些非对称的信息，比如区间的最大子段和、最大前缀和、最大后缀和等。这些信息不能简单地通过左右子区间的信息合并得到，需要额外的维护。

??? note "[区间最大子段和](https://www.luogu.com.cn/problem/SP1716){target=_blank}"

    求数组的区间最大子段和。

    !!! tip "最大子段和"

        一个区间的最大子段和可能出现在左子区间、右子区间，或者跨越左右子区间的中点。  
        因此，最大子段和需要维护四个属性：区间和、最大子段和、最大前缀和、最大后缀和。  
        其中，最大前缀和是指从区间左端点开始的连续子段的最大和，最大后缀和是指从区间右端点开始的连续子段的最大和。

    ```cpp
    --8<--  "code/DS/SegmentTree/SP1716.cpp"
    ```

## 区间最值和历史最值

在区间查询时，返回的不仅是当前的最值，还需要返回历史最值，即在所有的更新操作中，该区间曾经出现过的最值。

??? note "[【模板】线段树 3（区间最值操作、区间历史最值）](https://www.luogu.com.cn/problem/P6242){target=_blank}"

    !!! keypoints "区间设置最值、区间历史最值"

    !!! hint

        1. 区间设置最最小值操作只能将区间内的值变小，不能变大，因此如果区间的最大值已经小于等于设置值，则不需要进行任何操作。（设置最大值同理，维护区间最小值即可）  
        2. 区间历史最值需要在每次更新时，比较当前最大值与历史最大值，取较大者。  
        3. 区间加法操作分为对最大值的加法和对非最大值的加法两种情况，需要分别维护两个懒标记。  
        4. 区间加法操作会影响历史最值，因此需要分别维护最大值和非最大值达到过的最大涨幅。

    ```cpp
    --8<--  "code/DS/SegmentTree/P6242.cpp"
    ```

## 动态开点线段树

动态开点线段树（$\text{Dynamic Segment Tree}$）适用于处理大范围的区间查询和更新操作，尤其是在值域较大但实际使用的点较少的情况下。动态开点线段树通过按需创建节点来节省空间。