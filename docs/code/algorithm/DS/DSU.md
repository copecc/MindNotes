---
title: 并查集
tags:
  - 并查集
  - Union Find
  - Disjoint Set Union
  - DSU
---

# 并查集

并查集（$\text{Disjoint Set Union}，\text{DSU}$）是一种用于处理不交集（$\text{Disjoint Set}$）合并及查询问题的数据结构。它支持两种主要操作：

- $\text{Find}$: 查找元素所属的集合，并返回该集合的代表元素（根节点）
- $\text{Union}$: 合并两个元素所属的集合

## 普通并查集

在并查集中，为了提高效率，通常会使用按秩合并和路径压缩这两种优化策略。

-  按秩合并: 在合并两个集合时，总是将较小的树连接到较大的树上，从而保持树的平衡，减少树的高度
-  路径压缩: 在执行$\text{Find}$操作时，将访问路径上的所有节点直接连接到根节点，从而加速后续的$\text{Find}$操作

???+ note "[【模板】并查集](https://www.luogu.com.cn/problem/P3367){target=_blank}"

    ```cpp
    --8<-- "code/DS/DSU/P3367.cpp"
    ```

## 扩展域并查集

扩展域并查集（$\text{Extended Disjoint Set Union}$）是并查集的一种扩展应用。  
当需要处理元素之间存在多种关系（如朋友、敌人、捕食等）时，普通并查集只能处理元素是否属于同一集合的问题，无法满足需求。此时，可以通过扩展元素的表示范围，将一个元素拆分成多个域，每个域代表该元素在不同关系下的状态，从而利用并查集来处理这些复杂关系。  

??? example "朋友与敌人关系"

    在处理朋友和敌人关系时，可以将每个元素拆分成两个域：一个表示该元素的朋友集合，另一个表示该元素的敌人集合。  
    具体实现时，可以将每个元素 $x$ 拆分成两个节点 $x$ 和 $x + n$，其中 $n$ 是元素总数。节点 $x$ 代表 $x$ 的朋友集合，节点 $x + n$ 代表 $x$ 的敌人集合。  
    朋友的朋友是朋友，敌人的敌人是朋友，朋友的敌人是敌人，敌人的朋友是敌人。  
    当合并两个元素 $x$ 和 $y$ 的朋友关系时，需要同时合并 $x$ 的朋友集合和 $y$ 的朋友集合，以及 $x$ 的敌人集合和 $y$ 的敌人集合。  
    当合并两个元素 $x$ 和 $y$ 的敌人关系时，需要同时合并 $x$ 的朋友集合和 $y$ 的敌人集合，以及 $x$ 的敌人集合和 $y$ 的朋友集合。  
    在查询两个元素 $x$ 和 $y$ 的关系时，可以通过检查它们的朋友集合和敌人集合是否在同一个集合中来确定它们是朋友还是敌人。  

拓展域并查集的实现和普通并查集相似，只是在合并和查询时需要考虑不同域之间的关系。

??? note "[食物链](https://www.luogu.com.cn/problem/P2024){target=_blank}"

    有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。  
    现有 $N$ 个动物，以 $[1,N]$ 编号。每个动物都是 $A,B,C$ 中的一种，但并不知道具体是哪一种。  
    现在有 $K$ 条信息，可能是以下两种类型：

    - $1\ x\ y$：表示 $x$ 和 $y$ 是同类
    - $2\ x\ y$：表示 $x$ 吃 $y$
   
    由于信息可能有误，要求计算出其中有多少条是错误的。  

    ```cpp
    --8<-- "code/DS/DSU/P2024_1.cpp"
    ```

## 带权并查集

带权并查集（$\text{Weighted Disjoint Set Union}$）维护的是元素间的数值关系。  
常见形式是维护到父节点的权值 $weight[x]$，使得能通过与父节点的权值关系回答 $x$ 到 $y$ 的权值关系。  
如果只单独给出了一个节点的权重, 考虑能否添加一个虚拟节点,让该节点与虚拟节点之间的权重为该节点的权重。注意该虚拟节点应该**始终为根节点**。  

<br>
$\text{Find}$操作需要同时更新权值信息，$\text{Union}$操作需要调整权值以保持关系正确。  

1. $\text{Find}$: 在查找根节点的过程中，根据原来的父节点与根节点关系更新路径上每个节点的权值，使其直接指向根节点  
2. $\text{Union}$: 在合并两个集合时，调整其中一个集合的权值，以保持两个集合之间的数值关系(1)  
    {.annotate}

    1.  假设$weight[y]$ 是 $y$ 到 $root_y$ 的权重, $weight[x]$ 是 $x$ 到 $root_x$ 的权重，$value$ 是 $x$ 到 $y$ 的权重，在距离权重的意义下：<br>$root_x$ 到 $root_y$ ($root_x \rightarrow x \rightarrow y \rightarrow root_y$)的权重为: $-weight[x]$ + $value$ + $weight[y]$  


???+ note annotate "[推导部分和](https://www.luogu.com.cn/problem/P8779){target=_blank}"

    给定 $M$ 条信息，每条信息包含 $l, r, s$，表示区间 $[l, r]$ 的和为 $s$。  
    现在有 $Q$ 个询问，每个询问包含 $l, r$，询问区间 $[l, r]$ 的和。  
    如果无法确定区间和，输出 "UNKNOWN"。

    ```cpp
    --8<--  "code/DS/DSU/P8779.cpp"
    ```
1.  !!! tip
    习惯将区间距离 $[l,r]$ 表示为点 $l$ 到点 $r+1$ 的距离<br>例如区间 $[1,3]$ 的长度为 $5$, 则表示点 $1$ 到点 $4$ 的距离为 $5$


带权并查集也能处理分类问题（扩展域），只需将权值定义为类别关系即可。

??? note "[食物链(带权并查集解法)](https://www.luogu.com.cn/problem/P2024){target=_blank}"

    ```cpp
    --8<-- "code/DS/DSU/P2024_2.cpp"
    ```

## 可撤销并查集

可撤销并查集（$\text{Rollback Union-Find}$）是在普通并查集（$\text{Union-Find / DSU}$）的基础上，增加了撤销（$undo$）最近一次合并操作的能力。

在实现时，通常会使用一个栈来记录每次合并操作的状态变化，以便在需要撤销时能够恢复到之前的状态。并且只进行按秩合并，不进行路径压缩，以便于撤销操作的实现。

??? note "[Ball Collector](https://atcoder.jp/contests/abc302/tasks/abc302_h){target=_blank}"

    给定一棵有 $N$ 个节点的树，节点编号为 $1$ 到 $N$。每个节点上有两个球，每个球都有一个编号。从节点 $1$ 到节点 $i$ 的路径上，每个点只能收集一个球，计算每个节点能收集到的不同编号球的最大数量。

    ??? hint

        每个球的编号可以看作图中的一个节点，每个树节点提供了连接两个节点的边。设这个连通块包含的节点数为 $s$，边数为 $e$，如果 $e \lt s$，说明这个连通块仍然是树或者森林，新加一条边可以多收集一个不同编号的球；如果 $e \geq s$，说明这个连通块已经形成环路，新加一条边不能增加不同编号球的数量。

        使用可撤销并查集来处理。在进入一个节点时，合并路径上的球编号集合；在离开节点时，撤销合并操作，恢复到之前的状态。

    ```cpp
    --8<-- "code/DS/DSU/abc302_h.cpp"
    ```

!!! tip

    可撤销并查集不进行路径压缩，以便于撤销操作的实现。

    可撤销并查集配合分治、树状数组等数据结构，可以高效地处理动态连通性问题。