---
title: 重链剖分
tags:
  - 重链剖分
  - HLD
  - Heavy Light Decomposition
---

# 重链剖分

重链剖分（$\text{Heavy Light Decomposition}，\text{HLD}$）是一种将树划分为若干条链的技术，旨在将树上的路径查询和更新问题转化为链上的区间查询和更新问题，从而利用线段树或树状数组等数据结构高效地处理这些操作。

重链剖分的基本思想是将树中的每个节点划分为"重边"和"轻边"。对于每个节点，选择其子节点中子树大小最大的边作为重边，其余的边作为轻边。这样，从根节点到任意叶节点的路径上，重边的数量不会超过 $\log n$，其中 $n$ 是树的节点数。

通过重链剖分，可以将树上的路径查询和更新操作转化为若干条链上的区间查询和更新操作，从而利用线段树或树状数组等数据结构高效地处理这些操作。具体来说，重链剖分的步骤包括：

1. 计算子树大小：通过深度优先搜索（$\text{DFS}$）计算每个节点的子树大小
2. 划分重边和轻边：对于每个节点，选择子树大小最大的边作为重边，其余的边作为轻边
3. 编号：对每条链使用（$\text{DFS}$）编号得到 $\text{DFS}$ 序，保证同一条链上的节点在 $\text{DFS}$ 序中是连续的
4. 构建线段树或树状数组：根据链的编号和位置，构建[线段树](../DS/SegmentTree.md)或[树状数组](../DS/BIT.md)，以支持链上的区间查询和更新操作
5. 路径查询和更新：将树上的路径查询和更新操作转化为若干条链上的区间查询和更新操作，并利用线段树或树状数组高效地处理这些操作

!!! tip "$\text{DFN}$"

    $\text{DFN}$（$\text{Depth-First Numbering}$）是指在对树进行深度优先搜索（$\text{DFS}$）遍历时，为每个节点分配一个唯一的编号，编号的顺序与节点被访问的顺序一致。通过 $\text{DFN}$，可以将树上的节点映射到一个线性数组中，从而方便地进行区间查询和更新操作。

    ---

    对于路径查询和更新操作，可以将路径上的节点划分为若干条链，并在每条链上使用 $\text{DFN}$ 进行区间操作。

    子树节点的 $\text{DFN}$ 是连续的。假设节点 $u$ 的 $\text{DFN}$ 编号为 $dfn[u]$，其子树的大小为 $size[u]$，那么以 $u$ 为根的子树 $\text{DFN}$ 的范围可以表示为 $[dfn[u], dfn[u] + size[u] - 1]$。子树操作对应该区间。

    ---

    如果是边的性质，则下放到子节点，然后：

      - 对于路径操作，最后一步排除 $\text{LCA}$ 节点，即最后查询的是 $[dfn[u] + 1, dfn[v]]$。
      - 对于子树操作，排除根节点，即查询的是 $[dfn[u] + 1, dfn[u] + size[u] - 1]$。

    练习见[航线规划](https://www.luogu.com.cn/problem/P2542){target=_blank}，代码见[时光倒流](../Trick/BackInTime.md)。

???+ note "[【模板】重链剖分/树链剖分](https://www.luogu.com.cn/problem/P3384){target=_blank}"
    
    已知一棵包含 $N$ 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：

    1. 将路径 $u$ 到 $v$ 上的所有节点的数值加上 $k$。
    2. 查询路径 $u$ 到 $v$ 上所有节点的数值之和。
    3. 将以 $u$ 为根的子树上所有节点的数值加上 $k$。
    4. 查询以 $u$ 为根的子树上所有节点的数值之和。

    ```cpp
    --8<-- "code/Tree/HLD/P3384.cpp"
    ```
    {.annotate}

    5. 优先处理重儿子, 保证重链上的节点在 $\text{DFS}$ 序中是连续的, 重链上所有节点的链顶为 $top$
    6. 当 $u$ 和 $v$ 不在同一条链上时，提升较深节点所在链的链顶节点的父节点，直到 $u$ 和 $v$ 在同一条链上。  
       提升过程中记录区间和或进行区间更新。
    7. 当 $u$ 和 $v$ 在同一条链上时，直接计算区间和或进行区间更新。注意 $u$ 和 $v$ 的相对位置。
    8. 以 $u$ 为根的子树在 $\text{DFS}$ 序中的范围为 $[dfn[u], dfn[u] + size[u] - 1]$，直接对该区间进行查询或更新。

??? note "[【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379){target=_blank}"

    已知一棵包含 $N$ 个结点的树（连通且无环），需要处理 $M$ 次最近公共祖先（$\text{LCA}$）查询。

    其他解法见[最近公共祖先（LCA）](./LCA.md)。

    ```cpp
    --8<-- "code/Tree/HLD/P3379.cpp"
    ```

??? note "[树上最小公倍数追踪](https://niumacode.com/problem/P1828){target=_blank}"

    给定一棵有 $N$ 个节点的树和 $M$ 个查询，每个查询包含两个节点 $x$ 和 $y$，要求找出这两个节点的路径上所有节点值的最小公倍数。树的根节点为 $1$，节点编号从 $1$ 到 $N$。

    !!! warning "需要网站会员提交"

    ```cpp
    --8<-- "code/Tree/HLD/NM1828.cpp"
    ```