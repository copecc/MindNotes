---
title: 最小生成树
tags:
  - Minimum Spanning Tree
  - MST
---

# 最小生成树

最小生成树（$\text{Minimum Spanning Tree}, \text{MST}$）是指在一个连通加权无向图中，选取一部分边，使得所有节点都连通且边的权重之和最小的生成树。常用的算法有 $\text{Kruskal}$ 算法和 $\text{Prim}$ 算法。

## Kruskal算法

$\text{Kruskal}$ 算法的基本思想是将所有边按权重从小到大排序，然后依次选择边，若选择该边不会形成环，则将其加入生成树中，直到生成树包含所有节点为止。通常使用并查集（$\text{Union-Find}$）来检测环的形成。

???+ note "[【模板】最小生成树](https://www.luogu.com.cn/problem/P3366){target=_blank}"

    给定一个包含 $n$ 个节点和 $m$ 条边的无向图，求该图的最小生成树的权值和。如果图不连通，则输出 "orz"。

    ```cpp
    --8<-- "code/Graph/MST/P3366_1.cpp"
    ```

## Prim算法

$\text{Prim}$ 算法的基本思想是从一个节点开始，逐步扩展生成树，每次选择一条连接生成树和非生成树的边中权重最小的边，将其加入生成树，直到所有节点都包含在生成树中。通常使用优先队列（$\text{Priority Queue}$）来高效地选择最小权重边。

???+ note "[【模板】最小生成树](https://www.luogu.com.cn/problem/P3366){target=_blank}"

    ```cpp
    --8<-- "code/Graph/MST/P3366_2.cpp"
    ```
    {.annotate}

    1. 避免重复插入同一节点到优先队列中，确保每个节点只会被加入生成树一次。也可以省略，常数时间会稍微高一些。

## Kruskal重构树

$\text{Kruskal}$ 重构树是一种基于 $\text{Kruskal}$ 算法构建的树形结构，用于表示最小生成树的合并过程。每次合并两个连通分量时，创建一个新的节点表示该合并操作，并将两个被合并的节点作为其子节点，节点权重为边的权重。这样，最终得到的树的根节点表示整个图的最小生成树。

对于无向图，原图中两个点之间的所有简单路径上最大边权的最小值 $=$ 最小生成树上两个点之间的简单路径上的最大值 $=$ $\text{Kruskal}$ 重构树上两点之间的 $\text{LCA}$ 的权值。

对于有 $n$ 个节点的无向图，$\text{Kruskal}$ 重构树最多有 $2n-1$ 个节点，其中前 $n$ 个节点对应原图的节点，后 $n-1$ 个节点对应合并操作。

利用 $\text{Kruskal}$ 重构树，可以高效地处理一些与最小生成树相关的查询问题，例如查询两个节点在最小生成树中的最大边权等。



???+ note "[星际导航](https://www.luogu.com.cn/problem/P2245){target=_blank}"

    给定一个包含 $n$ 个节点和 $m$ 条边的无向图，询问 $q$ 次，每次询问两个节点 $u$ 和 $v$，求在最小生成树中连接 $u$ 和 $v$ 的路径上权重最大的边。如果 $u$ 和 $v$ 不连通，则输出 "impossible"。

    ```cpp
    --8<-- "code/Graph/MST/P2245.cpp"
    ```

??? note "[最小瓶颈路（加强版）](https://loj.ac/p/137){target=_blank}"

    给定一个 $n$ 个点 $m$ 条边的无向连通图，编号为 $1$ 到 $n$，没有自环，可能有重边，每一条边有一个正权值 $w$。

    给出 $q$ 个询问，每次给出两个不同的点 $u$ 和 $v$，求一条从 $u$ 到 $v$ 的路径上边权的最大值最小是多少。

    !!! warning "数据量 $n$ 和 $q$ 不同阶"

    ```cpp
    --8<-- "code/Graph/MST/LOJ137.cpp"
    ```